import { EventEmitter } from 'events';

// Data Models based on Spec
export interface CandidateProfile {
  id: string;
  name: string;
  domain: string; // e.g., 'software.backend'
  level: string; // e.g., 'Senior'
  langPref: string;
}

export interface Question {
  id: string;
  text: string;
  type: 'conceptual' | 'coding' | 'design' | 'debugging' | 'behavioral';
  difficulty: number; // 1-5
  topic: string;
  status: 'asked' | 'skipped' | 'answered';
  askedAt?: number;
}

export interface SessionState {
  sessionId: string;
  candidate: CandidateProfile;
  mode: string; // 'Conceptual', 'Hands-on Coding', 'System Design', 'Mixed'
  interviewerPersona: string; // 'Friendly Mentor', 'Tough Lead', etc.
  skillScore: number; // 0-100
  questionHistory: Question[];
  topicHistory: string[];
  turnCount: number;
  resourcesAllowed: {
    internet: boolean;
    compiler: boolean;
    calculator: boolean;
  };
  transcript: Array<{ role: 'ai' | 'user'; content: string; timestamp: number; analysis?: string }>;
  modelVersion: string;
  status: 'active' | 'completed' | 'paused';
}

export interface ForgeLinkParams {
  userId: string;
  mode: string;
  role: string;
  difficulty: string;
  persona: string;
}

export class SingularityEngine extends EventEmitter {
  private sessions: Map<string, SessionState>;

  constructor() {
    super();
    this.sessions = new Map();
  }

  async forgeLink(params: ForgeLinkParams): Promise<{ sessionId: string; initialGreeting: string }> {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const session: SessionState = {
      sessionId,
      candidate: {
        id: params.userId,
        name: 'Candidate', // Placeholder
        domain: params.role,
        level: params.difficulty,
        langPref: 'en'
      },
      mode: params.mode,
      interviewerPersona: params.persona,
      skillScore: 50, // Base score
      questionHistory: [],
      topicHistory: [],
      turnCount: 0,
      resourcesAllowed: {
        internet: false,
        compiler: true,
        calculator: true
      },
      transcript: [],
      modelVersion: 'gemini-interviewer-v1.0',
      status: 'active'
    };

    this.sessions.set(sessionId, session);

    // Initial Greeting (Mock for now, usually generated by AI)
    const initialGreeting = `Link forged. I am your ${params.persona} interviewer for the ${params.difficulty || 'standard'} ${params.role} role. Ready to begin?`;
    
    return { sessionId, initialGreeting };
  }

  getSession(sessionId: string): SessionState | undefined {
    return this.sessions.get(sessionId);
  }

  updateSession(sessionId: string, updates: Partial<SessionState>) {
    const session = this.sessions.get(sessionId);
    if (session) {
      Object.assign(session, updates);
      this.sessions.set(sessionId, session);
    }
  }

  addTranscriptEntry(sessionId: string, entry: { role: 'ai' | 'user'; content: string; analysis?: string }) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.transcript.push({ ...entry, timestamp: Date.now() });
      if (entry.role === 'ai') {
        session.turnCount++;
      }
    }
  }

  trackQuestion(sessionId: string, questionText: string) {
    const session = this.sessions.get(sessionId);
    if (session) {
      // Simple ID generation based on hash or random for now
      const id = `q_${Date.now()}`; 
      session.questionHistory.push({
        id,
        text: questionText,
        type: 'conceptual', // Default
        difficulty: 3, // Default
        topic: 'general',
        status: 'asked',
        askedAt: Date.now()
      });
    }
  }

  async processBiometrics(sessionId: string, biometrics: any) {
    const session = this.sessions.get(sessionId);
    if (session) {
      // Mock processing
      return { riftWarning: false, adjustment: null };
    }
    return { riftWarning: false };
  }

  async generateRiftInsights(sessionId: string) {
    const session = this.sessions.get(sessionId);
    // Dynamic score based on session duration/turns if available, otherwise random high score for demo
    const baseScore = session ? Math.min(99, 85 + (session.turnCount * 2)) : 90;
    const variance = Math.random() * 5;
    const finalScore = Math.min(100, baseScore + variance);
    
    return [
      { score: finalScore, metric: 'Entanglement' },
      { score: Math.max(70, finalScore - 5), metric: 'Neural Resonance' },
      { score: Math.max(80, finalScore + 2), metric: 'Cognitive Load' }
    ];
  }
}

export const singularityEngine = new SingularityEngine();
